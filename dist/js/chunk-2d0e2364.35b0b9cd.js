(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0e2364"],{"7e77":function(s,a,r){"use strict";r.r(a);var e=function(){var s=this,a=s.$createElement;s._self._c;return s._m(0)},t=[function(){var s=this,a=s.$createElement,r=s._self._c||a;return r("section",[r("h1",[s._v("自定义着色器Shader")]),r("p",[s._v("Three.js提供了RawShaderMaterial和ShaderMaterial两个API用来辅助开发者自定义着色器代码，所以在Three中ShaderMaterial编写着色器代码要比在原生的WenGL中编写着色器代码要方便，语法相同，但是Three渲染器会帮你自动设置一些代码。")]),r("pre",{pre:!0},[r("code",{pre:!0,attrs:{"v-pre":"",class:"language-javascript"}},[r("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// ShaderMaterial")]),s._v("\n"),r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("const")]),s._v(" shader = "),r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("new")]),s._v(" THREE.ShaderMaterial({\n    "),r("span",{pre:!0,attrs:{class:"hljs-attr"}},[s._v("vertexShader")]),s._v(": [ "),r("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// 顶点着色器，逐顶点运行该程序，顶点位置数据赋值给内置变量gl_Position")]),s._v("\n          "),r("span",{pre:!0,attrs:{class:"hljs-string"}},[s._v('"void main() {"')]),s._v(",\n          "),r("span",{pre:!0,attrs:{class:"hljs-string"}},[s._v('"gl_Position = vec4( position, 1.0 );"')]),s._v(",\n          "),r("span",{pre:!0,attrs:{class:"hljs-string"}},[s._v('"}"')]),s._v("\n    ].join("),r("span",{pre:!0,attrs:{class:"hljs-string"}},[s._v('"\\n"')]),s._v("),\n    "),r("span",{pre:!0,attrs:{class:"hljs-attr"}},[s._v("fragmentShader")]),s._v(": [ "),r("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// 片段着色器，逐片元处理，这里每个片元或者说像素设置为红色")]),s._v("\n          "),r("span",{pre:!0,attrs:{class:"hljs-string"}},[s._v('"void main() {"')]),s._v(",\n          "),r("span",{pre:!0,attrs:{class:"hljs-string"}},[s._v('"gl_FragColor = vec4(1.0,0.0,0.0,1.0);"')]),s._v(",\n          "),r("span",{pre:!0,attrs:{class:"hljs-string"}},[s._v('"}"')]),s._v("\n    ].join("),r("span",{pre:!0,attrs:{class:"hljs-string"}},[s._v('"\\n"')]),s._v("),\n})\n")])]),r("h2",[s._v("注意：")]),r("p",[s._v("使用ShaderMaterial API的好处就是在创建的时候Three.js渲染器系统会自动解析几何体对象Geometry中顶点位置、颜色、法向量等数据，然后在渲染的时候传递给着色器中的相应变量。不需要自己定义直接可以使用，比如上面的position")])])}],n=r("2877"),l={},p=Object(n["a"])(l,e,t,!1,null,null,null);a["default"]=p.exports}}]);